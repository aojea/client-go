/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package kubernetes

import (
	"context"
	"net"
	"strconv"
	"time"

	"k8s.io/klog/v2"

	discovery "k8s.io/client-go/discovery"
	admissionregistrationv1 "k8s.io/client-go/kubernetes/typed/admissionregistration/v1"
	admissionregistrationv1beta1 "k8s.io/client-go/kubernetes/typed/admissionregistration/v1beta1"
	internalv1alpha1 "k8s.io/client-go/kubernetes/typed/apiserverinternal/v1alpha1"
	appsv1 "k8s.io/client-go/kubernetes/typed/apps/v1"
	appsv1beta1 "k8s.io/client-go/kubernetes/typed/apps/v1beta1"
	appsv1beta2 "k8s.io/client-go/kubernetes/typed/apps/v1beta2"
	authenticationv1 "k8s.io/client-go/kubernetes/typed/authentication/v1"
	authenticationv1beta1 "k8s.io/client-go/kubernetes/typed/authentication/v1beta1"
	authorizationv1 "k8s.io/client-go/kubernetes/typed/authorization/v1"
	authorizationv1beta1 "k8s.io/client-go/kubernetes/typed/authorization/v1beta1"
	autoscalingv1 "k8s.io/client-go/kubernetes/typed/autoscaling/v1"
	autoscalingv2beta1 "k8s.io/client-go/kubernetes/typed/autoscaling/v2beta1"
	autoscalingv2beta2 "k8s.io/client-go/kubernetes/typed/autoscaling/v2beta2"
	batchv1 "k8s.io/client-go/kubernetes/typed/batch/v1"
	batchv1beta1 "k8s.io/client-go/kubernetes/typed/batch/v1beta1"
	batchv2alpha1 "k8s.io/client-go/kubernetes/typed/batch/v2alpha1"
	certificatesv1 "k8s.io/client-go/kubernetes/typed/certificates/v1"
	certificatesv1beta1 "k8s.io/client-go/kubernetes/typed/certificates/v1beta1"
	coordinationv1 "k8s.io/client-go/kubernetes/typed/coordination/v1"
	coordinationv1beta1 "k8s.io/client-go/kubernetes/typed/coordination/v1beta1"
	corev1 "k8s.io/client-go/kubernetes/typed/core/v1"
	discoveryv1alpha1 "k8s.io/client-go/kubernetes/typed/discovery/v1alpha1"
	discoveryv1beta1 "k8s.io/client-go/kubernetes/typed/discovery/v1beta1"
	eventsv1 "k8s.io/client-go/kubernetes/typed/events/v1"
	eventsv1beta1 "k8s.io/client-go/kubernetes/typed/events/v1beta1"
	extensionsv1beta1 "k8s.io/client-go/kubernetes/typed/extensions/v1beta1"
	flowcontrolv1alpha1 "k8s.io/client-go/kubernetes/typed/flowcontrol/v1alpha1"
	networkingv1 "k8s.io/client-go/kubernetes/typed/networking/v1"
	networkingv1beta1 "k8s.io/client-go/kubernetes/typed/networking/v1beta1"
	nodev1alpha1 "k8s.io/client-go/kubernetes/typed/node/v1alpha1"
	nodev1beta1 "k8s.io/client-go/kubernetes/typed/node/v1beta1"
	policyv1beta1 "k8s.io/client-go/kubernetes/typed/policy/v1beta1"
	rbacv1 "k8s.io/client-go/kubernetes/typed/rbac/v1"
	rbacv1alpha1 "k8s.io/client-go/kubernetes/typed/rbac/v1alpha1"
	rbacv1beta1 "k8s.io/client-go/kubernetes/typed/rbac/v1beta1"
	schedulingv1 "k8s.io/client-go/kubernetes/typed/scheduling/v1"
	schedulingv1alpha1 "k8s.io/client-go/kubernetes/typed/scheduling/v1alpha1"
	schedulingv1beta1 "k8s.io/client-go/kubernetes/typed/scheduling/v1beta1"
	storagev1 "k8s.io/client-go/kubernetes/typed/storage/v1"
	storagev1alpha1 "k8s.io/client-go/kubernetes/typed/storage/v1alpha1"
	storagev1beta1 "k8s.io/client-go/kubernetes/typed/storage/v1beta1"
	rest "k8s.io/client-go/rest"

	apierrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/sets"

	apidiscoveryv1beta1 "k8s.io/api/discovery/v1beta1"
)

// ClientsetPool allow to load balance the clientset to the endpoints defined in the API
// it implements a round robin strategy, if the current clientset fails it tries with the next one
type ClientsetPool struct {
	// host original host so we can fall back
	// if connection is totally lost
	host string
	// rest API configuration
	config *rest.Config
	// clientset in use
	clientset *Clientset
	// list with available API endpoints
	endpoints sets.String
	// healthcheck interval to get the list with available endpoints
	pollInterval time.Duration
}

var _ Interface = &ClientsetPool{}

// checkEndpoints check the avalable api endpoints
func (c *ClientsetPool) checkEndpoints() {
	var resVersion string
	t := time.NewTicker(c.pollInterval)
	for {
		select {
		case <-t.C:
			klog.Info("checking available apiserver version")
			_, err := c.clientset.Discovery().ServerVersion()
			if err != nil {
				c.nextApiServer()
			}
			klog.Info("checking available apiserver endpoints")
			endpointSlice, err := c.clientset.DiscoveryV1beta1().EndpointSlices("default").Get(context.TODO(), "kubernetes", metav1.GetOptions{})
			if err != nil {
				klog.Warningf("Error getting endpoints from %v: %v", c.config.Host, err)
				c.handleError(err)
			} else {
				// update the endpoints if there was changes
				if resVersion != endpointSlice.ResourceVersion {
					resVersion = endpointSlice.ResourceVersion
					c.updateApiserverEndpoints(*endpointSlice)
				}
			}
		}
	}
}

// handleError switch to the next available endpoint depending on the type of err
func (c *ClientsetPool) handleError(err error) {
	// use the next endpoint and discar the current one
	if apierrors.IsTimeout(err) ||
		apierrors.IsTooManyRequests(err) ||
		apierrors.IsUnauthorized(err) ||
		apierrors.IsUnexpectedServerError(err) ||
		apierrors.IsForbidden(err) ||
		apierrors.IsServerTimeout(err) {
		// create a new clientset with the next available endpoint if available
		// otherwise we keep using the original config file
		c.nextApiServer()
	}
}

func (c *ClientsetPool) nextApiServer() {
	if c.endpoints.Len() > 1 {
		c.config.Host, _ = c.endpoints.PopAny()
	} else {
		c.config.Host = c.host
	}
	klog.Infof("Switching apiserver endpoint to %s", c.config.Host)
	c.clientset, _ = NewForConfig(c.config)

}

// handleError switch to the next available endpoint depending on the type of err
func (c *ClientsetPool) updateApiserverEndpoints(slice apidiscoveryv1beta1.EndpointSlice) {
	urlPrefix := "http://"
	if rest.IsConfigTransportTLS(*c.config) {
		urlPrefix = "https://"
	}
	for _, ep := range slice.Endpoints {
		for _, address := range ep.Addresses {
			for _, port := range slice.Ports {
				host := urlPrefix + net.JoinHostPort(address, strconv.Itoa(int(*port.Port)))
				c.endpoints.Insert(host)
				klog.Infof("Updating available apiserver endpoints %s", host)
			}
		}
	}
}

// AdmissionregistrationV1 retrieves the AdmissionregistrationV1Client
func (c *ClientsetPool) AdmissionregistrationV1() admissionregistrationv1.AdmissionregistrationV1Interface {
	return c.clientset.admissionregistrationV1
}

// AdmissionregistrationV1beta1 retrieves the AdmissionregistrationV1beta1Client
func (c *ClientsetPool) AdmissionregistrationV1beta1() admissionregistrationv1beta1.AdmissionregistrationV1beta1Interface {
	return c.clientset.admissionregistrationV1beta1
}

// InternalV1alpha1 retrieves the InternalV1alpha1Client
func (c *ClientsetPool) InternalV1alpha1() internalv1alpha1.InternalV1alpha1Interface {
	return c.clientset.internalV1alpha1
}

// AppsV1 retrieves the AppsV1Client
func (c *ClientsetPool) AppsV1() appsv1.AppsV1Interface {
	return c.clientset.appsV1
}

// AppsV1beta1 retrieves the AppsV1beta1Client
func (c *ClientsetPool) AppsV1beta1() appsv1beta1.AppsV1beta1Interface {
	return c.clientset.appsV1beta1
}

// AppsV1beta2 retrieves the AppsV1beta2Client
func (c *ClientsetPool) AppsV1beta2() appsv1beta2.AppsV1beta2Interface {
	return c.clientset.appsV1beta2
}

// AuthenticationV1 retrieves the AuthenticationV1Client
func (c *ClientsetPool) AuthenticationV1() authenticationv1.AuthenticationV1Interface {
	return c.clientset.authenticationV1
}

// AuthenticationV1beta1 retrieves the AuthenticationV1beta1Client
func (c *ClientsetPool) AuthenticationV1beta1() authenticationv1beta1.AuthenticationV1beta1Interface {
	return c.clientset.authenticationV1beta1
}

// AuthorizationV1 retrieves the AuthorizationV1Client
func (c *ClientsetPool) AuthorizationV1() authorizationv1.AuthorizationV1Interface {
	return c.clientset.authorizationV1
}

// AuthorizationV1beta1 retrieves the AuthorizationV1beta1Client
func (c *ClientsetPool) AuthorizationV1beta1() authorizationv1beta1.AuthorizationV1beta1Interface {
	return c.clientset.authorizationV1beta1
}

// AutoscalingV1 retrieves the AutoscalingV1Client
func (c *ClientsetPool) AutoscalingV1() autoscalingv1.AutoscalingV1Interface {
	return c.clientset.autoscalingV1
}

// AutoscalingV2beta1 retrieves the AutoscalingV2beta1Client
func (c *ClientsetPool) AutoscalingV2beta1() autoscalingv2beta1.AutoscalingV2beta1Interface {
	return c.clientset.autoscalingV2beta1
}

// AutoscalingV2beta2 retrieves the AutoscalingV2beta2Client
func (c *ClientsetPool) AutoscalingV2beta2() autoscalingv2beta2.AutoscalingV2beta2Interface {
	return c.clientset.autoscalingV2beta2
}

// BatchV1 retrieves the BatchV1Client
func (c *ClientsetPool) BatchV1() batchv1.BatchV1Interface {
	return c.clientset.batchV1
}

// BatchV1beta1 retrieves the BatchV1beta1Client
func (c *ClientsetPool) BatchV1beta1() batchv1beta1.BatchV1beta1Interface {
	return c.clientset.batchV1beta1
}

// BatchV2alpha1 retrieves the BatchV2alpha1Client
func (c *ClientsetPool) BatchV2alpha1() batchv2alpha1.BatchV2alpha1Interface {
	return c.clientset.batchV2alpha1
}

// CertificatesV1 retrieves the CertificatesV1Client
func (c *ClientsetPool) CertificatesV1() certificatesv1.CertificatesV1Interface {
	return c.clientset.certificatesV1
}

// CertificatesV1beta1 retrieves the CertificatesV1beta1Client
func (c *ClientsetPool) CertificatesV1beta1() certificatesv1beta1.CertificatesV1beta1Interface {
	return c.clientset.certificatesV1beta1
}

// CoordinationV1beta1 retrieves the CoordinationV1beta1Client
func (c *ClientsetPool) CoordinationV1beta1() coordinationv1beta1.CoordinationV1beta1Interface {
	return c.clientset.coordinationV1beta1
}

// CoordinationV1 retrieves the CoordinationV1Client
func (c *ClientsetPool) CoordinationV1() coordinationv1.CoordinationV1Interface {
	return c.clientset.coordinationV1
}

// CoreV1 retrieves the CoreV1Client
func (c *ClientsetPool) CoreV1() corev1.CoreV1Interface {
	return c.clientset.coreV1
}

// DiscoveryV1alpha1 retrieves the DiscoveryV1alpha1Client
func (c *ClientsetPool) DiscoveryV1alpha1() discoveryv1alpha1.DiscoveryV1alpha1Interface {
	return c.clientset.discoveryV1alpha1
}

// DiscoveryV1beta1 retrieves the DiscoveryV1beta1Client
func (c *ClientsetPool) DiscoveryV1beta1() discoveryv1beta1.DiscoveryV1beta1Interface {
	return c.clientset.discoveryV1beta1
}

// EventsV1 retrieves the EventsV1Client
func (c *ClientsetPool) EventsV1() eventsv1.EventsV1Interface {
	return c.clientset.eventsV1
}

// EventsV1beta1 retrieves the EventsV1beta1Client
func (c *ClientsetPool) EventsV1beta1() eventsv1beta1.EventsV1beta1Interface {
	return c.clientset.eventsV1beta1
}

// ExtensionsV1beta1 retrieves the ExtensionsV1beta1Client
func (c *ClientsetPool) ExtensionsV1beta1() extensionsv1beta1.ExtensionsV1beta1Interface {
	return c.clientset.extensionsV1beta1
}

// FlowcontrolV1alpha1 retrieves the FlowcontrolV1alpha1Client
func (c *ClientsetPool) FlowcontrolV1alpha1() flowcontrolv1alpha1.FlowcontrolV1alpha1Interface {
	return c.clientset.flowcontrolV1alpha1
}

// NetworkingV1 retrieves the NetworkingV1Client
func (c *ClientsetPool) NetworkingV1() networkingv1.NetworkingV1Interface {
	return c.clientset.networkingV1
}

// NetworkingV1beta1 retrieves the NetworkingV1beta1Client
func (c *ClientsetPool) NetworkingV1beta1() networkingv1beta1.NetworkingV1beta1Interface {
	return c.clientset.networkingV1beta1
}

// NodeV1alpha1 retrieves the NodeV1alpha1Client
func (c *ClientsetPool) NodeV1alpha1() nodev1alpha1.NodeV1alpha1Interface {
	return c.clientset.nodeV1alpha1
}

// NodeV1beta1 retrieves the NodeV1beta1Client
func (c *ClientsetPool) NodeV1beta1() nodev1beta1.NodeV1beta1Interface {
	return c.clientset.nodeV1beta1
}

// PolicyV1beta1 retrieves the PolicyV1beta1Client
func (c *ClientsetPool) PolicyV1beta1() policyv1beta1.PolicyV1beta1Interface {
	return c.clientset.policyV1beta1
}

// RbacV1 retrieves the RbacV1Client
func (c *ClientsetPool) RbacV1() rbacv1.RbacV1Interface {
	return c.clientset.rbacV1
}

// RbacV1beta1 retrieves the RbacV1beta1Client
func (c *ClientsetPool) RbacV1beta1() rbacv1beta1.RbacV1beta1Interface {
	return c.clientset.rbacV1beta1
}

// RbacV1alpha1 retrieves the RbacV1alpha1Client
func (c *ClientsetPool) RbacV1alpha1() rbacv1alpha1.RbacV1alpha1Interface {
	return c.clientset.rbacV1alpha1
}

// SchedulingV1alpha1 retrieves the SchedulingV1alpha1Client
func (c *ClientsetPool) SchedulingV1alpha1() schedulingv1alpha1.SchedulingV1alpha1Interface {
	return c.clientset.schedulingV1alpha1
}

// SchedulingV1beta1 retrieves the SchedulingV1beta1Client
func (c *ClientsetPool) SchedulingV1beta1() schedulingv1beta1.SchedulingV1beta1Interface {
	return c.clientset.schedulingV1beta1
}

// SchedulingV1 retrieves the SchedulingV1Client
func (c *ClientsetPool) SchedulingV1() schedulingv1.SchedulingV1Interface {
	return c.clientset.schedulingV1
}

// StorageV1beta1 retrieves the StorageV1beta1Client
func (c *ClientsetPool) StorageV1beta1() storagev1beta1.StorageV1beta1Interface {
	return c.clientset.storageV1beta1
}

// StorageV1 retrieves the StorageV1Client
func (c *ClientsetPool) StorageV1() storagev1.StorageV1Interface {
	return c.clientset.storageV1
}

// StorageV1alpha1 retrieves the StorageV1alpha1Client
func (c *ClientsetPool) StorageV1alpha1() storagev1alpha1.StorageV1alpha1Interface {
	return c.clientset.storageV1alpha1
}

// Discovery retrieves the DiscoveryClient
func (c *ClientsetPool) Discovery() discovery.DiscoveryInterface {
	if c == nil {
		return nil
	}
	return c.clientset.DiscoveryClient
}

// NewLBForConfig creates a new ClientsetPool for the given config.
// If config's RateLimiter is not set and QPS and Burst are acceptable,
// NewForConfig will generate a rate-limiter in configShallowCopy.
func NewLBForConfig(c *rest.Config) (*ClientsetPool, error) {
	var cs ClientsetPool
	var err error
	cs.config = c
	cs.clientset, err = NewForConfig(cs.config)
	if err != nil {
		return nil, err
	}
	cs.endpoints = sets.NewString()
	cs.pollInterval = 10 * time.Second
	go cs.checkEndpoints()
	return &cs, nil
}

// NewLBForConfigOrDie creates a new ClientsetPool for the given config and
// panics if there is an error in the config.
func NewLBForConfigOrDie(c *rest.Config) *ClientsetPool {
	var cs ClientsetPool
	cs.config = c
	cs.clientset = NewForConfigOrDie(cs.config)
	cs.endpoints = sets.NewString()
	cs.pollInterval = 10 * time.Second
	go cs.checkEndpoints()
	return &cs
}
